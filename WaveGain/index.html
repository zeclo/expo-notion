<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ffmpeg.wasm loudnorm bridge</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 10px; }
    #status { font-size: 14px; color: #222; }
    #log { font-size: 12px; margin-top: 6px; white-space: pre-wrap; }
  </style>
</head>

<body>
  <div id="status">initializing...</div>
  <div id="log"></div>

  <script type="module">
    import { FFmpeg } from "https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.15/dist/esm/index.js";
    import { toBlobURL } from "https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/esm/index.js";

    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("log");

    const setStatus = (s) => {
      statusEl.textContent = s;
      console.log(s);
    };
    const log = (s) => {
      logEl.textContent += s + "\n";
      console.log(s);
    };

    const ffmpeg = new FFmpeg();
    let loaded = false;

    async function loadFFmpeg() {
      setStatus("loading ffmpeg...");
      const baseURL = "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/esm";
      const coreURL = await toBlobURL(`${baseURL}/ffmpeg-core.js`, "text/javascript");
      const wasmURL = await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, "application/wasm");
      await ffmpeg.load({ coreURL, wasmURL });
      loaded = true;
      setStatus("waiting for PROCESS");
    }

    loadFFmpeg();

    function base64ToUint8Array(b64) {
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    function uint8ArrayToBase64(bytes) {
      let binary = "";
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }

    async function handleProcess(data) {
      if (!loaded) {
        log("ffmpeg not ready");
        return;
      }

      const { id, inputBase64, inputName, outName, i, tp, lra } = data;
      setStatus(`processing ${id}`);

      const inputBytes = base64ToUint8Array(inputBase64);
      await ffmpeg.writeFile(inputName, inputBytes);

      const filter = `loudnorm=I=${i}:TP=${tp}:LRA=${lra}`;
      await ffmpeg.exec([
        "-i", inputName,
        "-af", filter,
        "-ar", "44100",
        "-ac", "2",
        outName
      ]);

      const outBytes = await ffmpeg.readFile(outName);
      const outBase64 = uint8ArrayToBase64(outBytes);

      try { await ffmpeg.deleteFile(inputName); } catch {}
      try { await ffmpeg.deleteFile(outName); } catch {}

      const payload = {
        type: "RESULT",
        id,
        mime: "audio/wav",
        outBase64,
        outName
      };

      window.ReactNativeWebView.postMessage(JSON.stringify(payload));
      setStatus(`done ${id}`);
      log(`processed ${outBytes.length} bytes`);
    }

    window.addEventListener("message", (ev) => {
      let data;
      try { data = JSON.parse(ev.data); } catch { return; }
      if (data?.type === "PROCESS") {
        handleProcess(data);
      }
    });
  </script>
</body>
</html>
